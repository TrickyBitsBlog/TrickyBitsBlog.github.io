<!DOCTYPE html>
<html lang="en">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Under the hood of Windows timestamps | Tricky Bits</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Under the hood of Windows timestamps" />
<meta name="author" content="Rob" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Under the hood of windows timestamps, the details and the history" />
<meta property="og:description" content="Under the hood of windows timestamps, the details and the history" />
<link rel="canonical" href="https://trickybitsblog.github.io/2024/02/25/timestamps.html" />
<meta property="og:url" content="https://trickybitsblog.github.io/2024/02/25/timestamps.html" />
<meta property="og:site_name" content="Tricky Bits" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-25T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Under the hood of Windows timestamps" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Rob"},"dateModified":"2024-02-25T00:00:00-07:00","datePublished":"2024-02-25T00:00:00-07:00","description":"Under the hood of windows timestamps, the details and the history","headline":"Under the hood of Windows timestamps","mainEntityOfPage":{"@type":"WebPage","@id":"https://trickybitsblog.github.io/2024/02/25/timestamps.html"},"url":"https://trickybitsblog.github.io/2024/02/25/timestamps.html"}</script>
<!-- End Jekyll SEO tag -->

<head>
    

<link rel="stylesheet" href="https://trickybitsblog.github.io/assets/style.css"/>



<style>
  blockquote {
    color: rgb(111, 111, 111);
    margin-left: 40;
    margin-right: 40;
    border-left: solid;
  }

  code {
    color:rgb(154, 99, 33)
  }
</style>



<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="Tricky Bits" />
<meta 
    property="og:title"
    content="
        
            Under the hood of Windows timestamps
        
    " 
/>

<meta property="og:url" content="https://trickybitsblog.github.io//2024/02/25/timestamps.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        Under the hood of Windows timestamps
    
</title>
  </head>
<body class="index">
    <script src="https://trickybitsblog.github.io/assets/js/lib/jquery-3.7.0.min.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-5YPZXPQW94"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5YPZXPQW94');
</script>








    <header class="header">
  
  <section class="logo">
            

              
                <a href="https://trickybitsblog.github.io/" class="logo__link">

                  <h1 style="display: none;">Tricky Bits</h1>
                  <img class="logo__link__img" src="/assets/img/tricky-bits-blog-medium.png" />
                </a>
                

            
    </section>
    
    
    <button id="menuToggle">
        <div></div>
        <div></div>
        <div></div>
    </button>
    <nav class="menu">
        
<ul class="list primary">

    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/blog.html">
                
                
                    <img src="https://trickybitsblog.github.io/assets/img/icons/blog.svg"/>
                
                <div class="">
                
                    <p style="color: var(--c-themePrimaryLight)">Blog</p>
                
                </div>
                </a>

            
                <a class="button-submenu" href="#"><i class="arrow"></i></a>
            </div>
                
<ul class="list">

    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/graphics.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Graphics</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/apple.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Apple</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/windows.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Windows</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/bits.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Bits n Bytes</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/retro.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Retro</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/random.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Random</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/business.html">
                
                
                <div class="">
                
                    <p style="color: var(--c-themeHueOrange)">Business</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
</ul>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/category/podcast.html">
                
                
                    <img src="https://trickybitsblog.github.io/assets/img/icons/podcast.svg"/>
                
                <div class="">
                
                    <p style="color: var(-c-themePrimaryLight)">Podcast</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                
                <a href="https://trickybitsblog.github.io/pages/about.html">
                
                
                    <img src="https://trickybitsblog.github.io/assets/img/icons/info-icon.svg"/>
                
                <div class="">
                
                    <p style="color: var(--c-themePrimaryLight)">About</p>
                
                </div>
                </a>

            
            </div>
            
        </li>   
    
</ul>   
    </nav>
    
</header>


    <article class="post">

  
  <div class="post__title">
      <h1 class="post__title__text">Under the hood of Windows timestamps</h1>
  </div>    
  

    <div class="post__meta"> 
        <div class="post__meta__category">
            
                <p class="post__meta__category__title" style="background: var(--c-postBlog)">Tricky Bits Blog Posts</p>
            
                <p class="post__meta__category__title" style="background: var(--c-postWindows)">Windows</p>
            
                <p class="post__meta__category__title" style="background: var(--c-postBits)">Bits n Bytes</p>
            
        </div>
        <p class="post__meta__divider">·</p>
        <div class="post__meta__date">
            February 25, 2024
        </div>
        
            
            <p class="post__meta__divider">·</p>
            <div class="post__meta__author">
                <p>by </p>
                <img class="post__meta__author__photo" src="https://trickybitsblog.github.io/assets/img/authors/rob-thumb.jpg"/>
                <p>Rob Wyatt</p>
            </div>
        
    </div>

    

    <div class="post__content">
        <p>Programmers have always needed reliable timestamps and programming on Windows is no different. But getting accurate timestamps efficiently from user mode, a seemingly simple task that every operating system supports, seems to have at best made Microsoft jump through hoops for 30 years, and at worst eluded them completely.</p>

<p>Compared to Linux, where the <code class="language-plaintext highlighter-rouge">clock_gettime</code> API will return all sorts of time stamps to a standardized nanosecond resolution, Windows is not so simple and this leads to assumptions and a quagmire of edge cases. Sure Windows has a complicated legacy and there are lots of backwards compatibility issues that still dictate how time works to this day, buy why is it that even in Windows 11 there not a time API with standard units? Why do we always have to convert from some arbitrary frequency - which only aid assumptions and bad programming? These timing assumptions and other edge cases are typically what cause old software to misbehave when running on modern machines. Old applications sometimes stutter, run too slow, run too fast and sometimes outright crash. These misbehaving apps are not directly Microsoft’s fault, the apps are usually victims of assumptions that were valid at the time.</p>

<p>In this post we are taking a deep dive in to the Windows time APIs to see exactly how they work and how they evolved, from DOS to hypervisors, and we’ll figure out what modern apps should be using and we’ll see that Windows 11 gets pretty close to a standard timer but not quite, but its close enough that it will probably lead to more bad assumptions in the future.</p>

<hr />

<p>For a fleeting moment it seemed like we could avoid all time based APIs and do things ourselves. Starting with the original Pentium processor, some 30 years ago, Intel added the <code class="language-plaintext highlighter-rouge">RDTSC</code> instruction, this reads a hardware time stamp counter (TSC) that incremented every clock cycle, and for the first time applications had a hardware counter that was accessible with low latency in user mode that would provide cycle level precision. For a while all of our timing problems were solved, even a lowly 100Mhz Pentium could give 10ns timestamps, compute accurate elapsed time periods, code could easily be profiled to see the results of the smallest micro optimizations; all things that were exceptionally difficult or impossible with the windows time APIs at the time. However, it didn’t last, while <code class="language-plaintext highlighter-rouge">RDTSC</code> was used all over the place it became very unreliable and a lot of software broke.</p>

<p>Early multiple processor systems had physically different processors in physically different packages and each would have its own none-synchronized TSC. If your code switched processors the <code class="language-plaintext highlighter-rouge">RDTSC</code> instruction could give the impression of time going backwards which causes all sorts of problems. Lots of games and media apps that were written in the days of single processors suffered timing problems due to this. It wasn’t just third party code, even system tools suffered, for example <code class="language-plaintext highlighter-rouge">ping</code> on an early Windows Server sometimes fails with negative time!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\&gt;ping google.com

Ping google.com (142.250.69.238) with 32 bytes of data:
Reply from 142.250.69.238: bytes=32 time=-59ms TTL=128
Reply from 142.250.69.238: bytes=32 time=-59ms TTL=128
Reply from 142.250.69.238: bytes=32 time=-59ms TTL=128
Reply from 142.250.69.238: bytes=32 time=-59ms TTL=128
</code></pre></div></div>

<p>Over time using <code class="language-plaintext highlighter-rouge">RDTSC</code> on single processors became unreliable because TSC would increment at the raw clock speed of the processor; which wasn’t stable. The frequency would change small amounts due to spread spectrum clocking but would change by huge amounts due to thermal and power management which made TSC unusable. To make things worse, variable frequency clocking happened around the same time as multi-processor machines started to get commonplace so it was a double whammy. <code class="language-plaintext highlighter-rouge">RDTSC</code> could still be used, albeit with great care, but it was generally impossible to correlate the TSC to wall time.  Today this problem is fixed via an invariant TSC which increments at a fixed rate in all power and thermal states, from a software point of view the invariant TSC increments at the base clock speed of the processor, regardless of the actual operating speed. TSC can once again be used for accurate timing as it directly correlates to wall time but Microsoft still recommends to not use the <code class="language-plaintext highlighter-rouge">RDTSC</code> instruction and instead use the <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> API, is this true??? Before we answer that question and dive in to the nitty gritty of <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> along with the role the TSC plays in modern Windows operating systems, lets look at the methods used to get time prior to <code class="language-plaintext highlighter-rouge">RDTSC</code>. There is a lot of history here and its not hard to figure out why <code class="language-plaintext highlighter-rouge">RDTSC</code> got used so much.</p>

<hr />

<p>Prior to <code class="language-plaintext highlighter-rouge">RDTSC</code>, and during the many years that <code class="language-plaintext highlighter-rouge">RDTSC</code> couldn’t reliably be used, Windows only had a few options for elapsed time, most of them were timer interrupt driven, and none of them were great. Stuttering in early games and media was often the result of poor time. <code class="language-plaintext highlighter-rouge">GetTickCount()</code> has been in the Windows API since the 16bit days, it still exists today and is used everywhere. It returns the integer number of milliseconds since the system was booted. The resulting 32bit counter will wrap in 49.7 days and to avoid this modern versions of Windows have <code class="language-plaintext highlighter-rouge">GetTickCount64()</code> which is identical in functionality other than returning a 64bit result. Realistically having a timer wrap in 49.7 days probably wasn’t an issue for Windows3.1 because it wouldn’t stay on that long. While the accuracy of the <code class="language-plaintext highlighter-rouge">GetTickCount()</code> is 1ms, it’s resolution has never been close and still isn’t. Initially the resolution of this API was a whopping 55ms and this was true all the way though the Win9x operating systems, for Windows NT based operating systems the resolution has always been 10-15ms, where it still is today, even on Windows 11.</p>

<p>To understand were the 55ms interval comes from, which seems like a very random number in computer terms, we have to go all the way back to the origins of the PC BIOS. The original IBM PC ran at approximately 4.77MHz, it was clocked at quarter speed by a 1.19318MHz crystal and this also clocked the 8254 programmable interval timer. 65536 cycles at 1.19318MHz is 54.92ms. The timer generated a 18.208Hz interrupt on IRQ8 which was used by the BIOS to track wall time. Early PCs didn’t have a battery backed clock so had no concept of wall time, the user would enter the date and time at boot and the BIOS would keep track of wall time using this interrupt. With 18.208Hz interrupt rate, 2^16 interrupts equals approximately 3599.59 seconds, which is almost exactly one hour. To save a few CPU cycles the BIOS used this almost once an hour 16-bit overflow to check whether the wall time had crossed midnight and when it did, it needed to increment the date.</p>

<p>Lots of DOS games hijacked the 8254 timer hardware and installed their own interrupt handler, so DOS game had access to accurate time. Early Windows ran on top of DOS and used all the DOS and BIOS services as-is, therefore it didn’t mess with the timer hardware. The original <code class="language-plaintext highlighter-rouge">GetTickCount()</code> API was a wrapper for the BIOS timer interrupt, it literally counted interrupts and multiplied that by 54.92 to compute elapsed time in milliseconds. As an optimization, the API did the multiplication only when it was called, amazingly it is still implemented this way on Windows 11 and although the origin of the tick counter is a little different the resolution is still only about 15ms. NT based operating systems were never based on DOS and the NT kernel did hijack the hardware timer. On a single processor NT machine the interrupt period was set to about 10ms, while on a multi processor machines about 15ms; much better than 55ms from 16bit windows and win9x but nowhere near good enough for games and media.</p>

<p>A common pattern within Windows NT based operating systems is to have documented public Win32 APIs that are internally implemented with the somewhat undocumented native API. <code class="language-plaintext highlighter-rouge">GetTickCount</code> was no different, it had been a documented API since the first version of Windows and on Windows NT it simply wrapped the native API <code class="language-plaintext highlighter-rouge">NtGetTickCount</code> which was originally a system call to the kernel.  Therefore getting the elapsed time involved a system call. Today system calls are still expensive and optimizations are in place to avoid them, 30 years ago they were really expensive..</p>

<p>Today, <code class="language-plaintext highlighter-rouge">GetTickCount</code> is just a few instructions, there are no system calls and it doesn’t call <code class="language-plaintext highlighter-rouge">NtGetTickCount</code> (which is implemented identically).</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">GetTickCount:</span>
<span class="nf">mov</span>         <span class="nb">ecx</span><span class="p">,</span><span class="mh">7FFE0320h</span>               <span class="c1">;get the interrupt count</span>
<span class="nf">mov</span>         <span class="nb">rcx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span>         
<span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="mh">7FFE0004h</span><span class="p">]</span>   <span class="c1">;get a 24bit fixed point multiplier (defined by the interrupt period)</span>
<span class="nf">imul</span>        <span class="nb">rax</span><span class="p">,</span><span class="nb">rcx</span>                     <span class="c1">;multiply</span>
<span class="nf">shr</span>         <span class="nb">rax</span><span class="p">,</span><span class="mh">18h</span>                     <span class="c1">;shift down to give integer milliseconds</span>
<span class="nf">ret</span>  
</code></pre></div></div>

<hr />

<p>In the disassembly above it, while it doesn’t use any sycalls, it does read from hardcoded addresses <code class="language-plaintext highlighter-rouge">0x7FFE0320</code> and <code class="language-plaintext highlighter-rouge">0x7FFE0004</code>. These addresses are part of what is known as <code class="language-plaintext highlighter-rouge">kuser_shared</code>, this was first implemented in Windows NT 3.5 and has been there, in some form, ever since. <code class="language-plaintext highlighter-rouge">kuser_shared</code> is a read only memory page mapped to every process by the kernel at fixed address <code class="language-plaintext highlighter-rouge">0x7FFE0000</code>. This allows the kernel to share things like constants, counters and configuration data without having to rely on system calls, user mode code can simply read the data from memory at full speed, and all user mode processes see the same data at the same time. It’s intended for internal use and was never officially documented until <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data">Windows 10 DDK</a>. Needless to say there are a lot of elements in <code class="language-plaintext highlighter-rouge">kuser_shared</code> that relate to time.</p>

<blockquote>
  <p>It’s highly recommended that production code doesn’t poke around in <code class="language-plaintext highlighter-rouge">kuser_shared</code>, it can change between even minor versions of windows; but it’s exactly what we’re going to do.</p>
</blockquote>

<p>Looking back at the disassembly above we can make sense of it. <code class="language-plaintext highlighter-rouge">0x7FFE0320</code> is a 64bit counter, the kernel increments this every tick interrupt. This used to be a 32bit counter at address <code class="language-plaintext highlighter-rouge">0x7FFE0000</code> but that location is no longer used and is zero; a perfect example of why production code shouldn’t use <code class="language-plaintext highlighter-rouge">kuser_shared</code> directly and why some old applications that did no longer work. <code class="language-plaintext highlighter-rouge">0x7FFE004</code> is known as the <code class="language-plaintext highlighter-rouge">TickCountMultiplier</code> and is the interrupt period in units of 100ns, shifted left by 24 bits, and divided by 10,000. Thr conversion of raw tick count to integer milliseconds is simply a multiplication of TickCountMultiplier and a shift right by 24 bits, which is exactly what the above code does (and is pretty much exactly what 16bit windows did).</p>

<p>Today, most machines today have a multiplier of <code class="language-plaintext highlighter-rouge">0x0FA00000</code> which works out to be a period of 156250 (100ns system units) or 15.6250ms. Even in 2024, using Windows 11, the tick interrupt period is 15.625ms and this is the resolution of <code class="language-plaintext highlighter-rouge">GetTickCount</code> - about the same as all the earlier NT based cousins. While the value for the tick count multiplier has been constant at <code class="language-plaintext highlighter-rouge">0x0FA00000</code> for a while, you shouldn’t rely on it and you certainly shouldn’t compute the tick period directly from the multiplier at <code class="language-plaintext highlighter-rouge">0x7FFE0004</code>. There are more legitimate ways to get the tick period from the kernel.</p>

<p>At this point it is worth noting that the tick count at <code class="language-plaintext highlighter-rouge">0x7FFE0320</code>, which drives <code class="language-plaintext highlighter-rouge">GetTickCount</code>, isn’t driven directly from a hardware interrupt like it used to be. Instead, the tick count is abstracted from the more modern kernel interval timer interrupt, which can, and does, change its period on the fly. If I remember from my time on the the Windows kernel, the timer interval interrupt is handled by a function called <code class="language-plaintext highlighter-rouge">KeUpdataSystemTime</code> and in this function the kernel updates the interval interrupt time and then simply decrements the remaining TickCount period with the elapsed time since the last interval interrupt (in 100nS units), when this counter period reaches zero the tick counter at location <code class="language-plaintext highlighter-rouge">0x7FFE0320</code> is incremented - it’s kind crude.  Due to this, the kernel intereval timer interrupt may occur much faster than the tick period but it can never be slower otherwise the tick counter would miss increments.  On my machine the kernel interval interrupt occurs somewhere between 0.5ms and 15.625ms.</p>

<p>Its really important to note that the period of the kernel interval timer interrupt doesn’t have to be a factor of 15.625ms (the tick count speed), in can be anything between the min and max timer period. Therefore, the the tick counter at location <code class="language-plaintext highlighter-rouge">0x7FFE0320</code> might average out to its actual period of 15.625ms, but it has a whole lot of jitter, if the kernel interval timer is set at 7ms, then the kernel might not update the tick count at <code class="language-plaintext highlighter-rouge">0x7FFE0320</code> until 21ms have elapsed.</p>

<blockquote>
  <p>The various counters in <code class="language-plaintext highlighter-rouge">kuser_shared</code> are updated without the need for locks on multi-processor machines. The older 32bit versions of Windows had to jump through a few hoops to ensure the 64bit values were reliably updated.
Everything in this post assumes a modern 64bit version of Windows.</p>
</blockquote>

<p>Here is some test code that show this in real time.  The code spins while it waits for the kernel interval timer interrupt at location <code class="language-plaintext highlighter-rouge">0x7FFE0008</code> to change (this address is the time of the last kernel interval timer interrupt in units of 100ns since boot, its set by the kernel itself within the interrupt handler). The code then looks to see if the tick count has changed and if it has computes the elapsed time from the last update.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="mh">0x7FFE0008</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">old_tick</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="mh">0x7FFE0320</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">last_tick_change</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="mh">0x7FFE0008</span><span class="p">;</span>

    <span class="c1">//has a kernel interrupt fired</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">current</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">uint64_t</span> <span class="n">kdelta</span> <span class="o">=</span> <span class="n">current</span> <span class="o">-</span> <span class="n">old</span><span class="p">;</span>
      <span class="kt">uint64_t</span> <span class="n">tick_count</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="mh">0x7FFE0320</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">tick_count</span> <span class="o">==</span> <span class="n">old_tick</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ktimer = %lld (kdelta=%lld), tick=%lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">kdelta</span><span class="p">,</span> <span class="n">tick_count</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">else</span> 
      <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ktimer = %lld (kdelta=%lld), tick=%lld, tick_delta=%lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">kdelta</span><span class="p">,</span> <span class="n">tick_count</span><span class="p">,</span> <span class="n">current</span> <span class="o">-</span> <span class="n">last_tick_change</span><span class="p">);</span>
        <span class="n">last_tick_change</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="n">old_tick</span> <span class="o">=</span> <span class="n">tick_count</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">old</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here are real results from my windows 11 test machine, the amount of jitter in tick_delta is not good.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>initially the timer was running at about 1ms intervals
you can see the tick delta from the previous update is 15.9ms

This 1ms interval continues until it switches to 10ms

ktimer = 4946927507603 (kdelta=9994), tick=31660336, tick_delta=159942
ktimer = 4946927517606 (kdelta=10003), tick=31660336
ktimer = 4946927527603 (kdelta=9997), tick=31660336
ktimer = 4946927537604 (kdelta=10001), tick=31660336
ktimer = 4946927547608 (kdelta=10004), tick=31660336
ktimer = 4946927557606 (kdelta=9998), tick=31660336
ktimer = 4946927567603 (kdelta=9997), tick=31660336
ktimer = 4946927577604 (kdelta=10001), tick=31660336
ktimer = 4946927587604 (kdelta=10000), tick=31660336
ktimer = 4946927597603 (kdelta=9999), tick=31660336
ktimer = 4946927607618 (kdelta=10015), tick=31660336
ktimer = 4946927617607 (kdelta=9989), tick=31660336

Here is where the interrupt interval switches to 10ms, and it because of this
the next tick update doesn't occur until 21ms. 
With a 10ms interval the best the 15.625ms tick can do is bounce between 10 and 20ms

ktimer = 4946927718095 (kdelta=100488), tick=31660337, tick_delta=210492
ktimer = 4946927818092 (kdelta=99997), tick=31660338, tick_delta=99997
ktimer = 4946927918095 (kdelta=100003), tick=31660338
ktimer = 4946928018092 (kdelta=99997), tick=31660339, tick_delta=200000
ktimer = 4946928118084 (kdelta=99992), tick=31660339
ktimer = 4946928218105 (kdelta=100021), tick=31660340, tick_delta=200013
ktimer = 4946928318081 (kdelta=99976), tick=31660341, tick_delta=99976
ktimer = 4946928418096 (kdelta=100015), tick=31660341
ktimer = 4946928518105 (kdelta=100009), tick=31660342, tick_delta=200024
ktimer = 4946928618088 (kdelta=99983), tick=31660343, tick_delta=99983
ktimer = 4946928718076 (kdelta=99988), tick=31660343
ktimer = 4946928818082 (kdelta=100006), tick=31660344, tick_delta=199994

from here the interval is quite random for a while

ktimer = 4946928848076 (kdelta=29994), tick=31660344
ktimer = 4946928858169 (kdelta=10093), tick=31660344
ktimer = 4946928867110 (kdelta=8941), tick=31660344
ktimer = 4946928868757 (kdelta=1647), tick=31660344
ktimer = 4946928869416 (kdelta=659), tick=31660344
ktimer = 4946928947830 (kdelta=78414), tick=31660345, tick_delta=129748
ktimer = 4946928948959 (kdelta=1129), tick=31660345
ktimer = 4946928958946 (kdelta=9987), tick=31660345
ktimer = 4946928967940 (kdelta=8994), tick=31660345
ktimer = 4946929063042 (kdelta=95102), tick=31660346, tick_delta=115212
</code></pre></div></div>

<p>You don’t have to compute the elapsed time between 2 timer interrupts to work out the current speed of the kernel interval timer, we can use native api function <code class="language-plaintext highlighter-rouge">NtQueryTimerResolution</code>, this fills out the minimum resolution (slowest timer rate), the maximum resolution (fastest timer rate), and the current resolution at the time it was called (all in 100ns system time units). The minimum resolution for the kernel interval timer will always be the the tick count interval, this ensures the tick counter always increments monotonically and never misses a value.</p>

<blockquote>
  <p>There are no easily accessible headers for the native API. You have to declare the functions yourself and either link with static library ntdll.lib, or use <code class="language-plaintext highlighter-rouge">GetProcAddress</code> on ntdll.dll to dynamically link.</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="n">NTSYSAPI</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtQueryTimerResolution</span><span class="p">(</span>
  <span class="n">OUT</span> <span class="n">PULONG</span> <span class="n">MinimumResolution</span><span class="p">,</span>
  <span class="n">OUT</span> <span class="n">PULONG</span> <span class="n">MaximumResolution</span><span class="p">,</span> 
  <span class="n">OUT</span> <span class="n">PULONG</span> <span class="n">CurrentResolution</span><span class="p">);</span>


  <span class="c1">//get the min, max and current resolution</span>
  <span class="n">ULONG</span> <span class="n">minRes</span><span class="p">;</span>
  <span class="n">ULONG</span> <span class="n">maxRes</span><span class="p">;</span>
  <span class="n">ULONG</span> <span class="n">currentRes</span><span class="p">;</span>
  <span class="n">NtQueryTimerResolution</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minRes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxRes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">currentRes</span><span class="p">);</span>
</code></pre></div></div>

<p>On my machine <code class="language-plaintext highlighter-rouge">NtQueryTimerResolution</code> reports a minimum period (maximum resolution) of 5000 or 0.5ms and a maximum period (minimum resolution) of 156250 or 15.625ms. Calling this in a loop and displaying the current resolution will should the kernel timer changing resolution on the fly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kernel timer resolution = 156250
kernel timer resolution = 100000
kernel timer resolution = 156250
kernel timer resolution = 10000
kernel timer resolution = 10000
kernel timer resolution = 10000
kernel timer resolution = 156250
</code></pre></div></div>

<p>The reason is the kernel timer resolution changes is because it’s a system wide setting. The default value is the minimum resolution (15.625ms) but it will change as other processes ask for a different resolution, the final resolution will always be set to the minimum interval that has been asked for by any process - this is not a bad random seed because it depends entirely on the processes that are running and what they are currently doing. In both of the above time logs it is easy to see that periodically some process is asking for 1ms resolution, which is common due to how the newer multimedia timers work, but in order to satisfy such a request, everybody gets 1ms resolution.</p>

<p>The timer resolution can be set directly using native API <code class="language-plaintext highlighter-rouge">NtSetTimerResolution</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="s">"C"</span> <span class="n">NTSYSAPI</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span> <span class="nf">NtSetTimerResolution</span><span class="p">(</span><span class="n">ULONG</span> <span class="n">DesiredResolution</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">SetResolution</span><span class="p">,</span> <span class="n">PULONG</span> <span class="n">CurrentResolution</span><span class="p">);</span>

<span class="c1">//currentRes will be set to the current resolution, it may not be what you asked for if some other process has asked for a higher resolution. </span>
<span class="n">ULONG</span> <span class="n">currentRes</span><span class="p">;</span>
<span class="n">NtSetTimerResolution</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">currentRes</span><span class="p">);</span>
</code></pre></div></div>

<p>The resolution has to be between the min and max reported by <code class="language-plaintext highlighter-rouge">NtQueryTimerResolution</code> and it returns the current set resolution, which may not be what you asked because some other process may have already set it to a higher resolution. If we always set the maximum resolution, then the timer rate should be constant because no other process will be able to change it.  Including a call to <code class="language-plaintext highlighter-rouge">NtSetTimerResolution</code> and running the same log again we get much cleaner results, the kernel timer fires every 5000 time units (0.5ms) and the jitter across the tick counter is much more consistent.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ktimer = 4948512812590 (kdelta=5001), tick=31670482, tick_delta=155002
ktimer = 4948512817589 (kdelta=4999), tick=31670482
ktimer = 4948512822590 (kdelta=5001), tick=31670482
ktimer = 4948512827590 (kdelta=5000), tick=31670482
ktimer = 4948512832590 (kdelta=5000), tick=31670482
ktimer = 4948512837589 (kdelta=4999), tick=31670482
ktimer = 4948512842590 (kdelta=5001), tick=31670482
ktimer = 4948512847589 (kdelta=4999), tick=31670482
ktimer = 4948512852589 (kdelta=5000), tick=31670482
ktimer = 4948512857593 (kdelta=5004), tick=31670482
ktimer = 4948512862590 (kdelta=4997), tick=31670482
ktimer = 4948512867595 (kdelta=5005), tick=31670482
ktimer = 4948512872589 (kdelta=4994), tick=31670482
ktimer = 4948512877588 (kdelta=4999), tick=31670482
ktimer = 4948512882589 (kdelta=5001), tick=31670482
ktimer = 4948512887589 (kdelta=5000), tick=31670482
ktimer = 4948512892589 (kdelta=5000), tick=31670482
ktimer = 4948512897589 (kdelta=5000), tick=31670482
ktimer = 4948512902600 (kdelta=5011), tick=31670482
ktimer = 4948512907592 (kdelta=4992), tick=31670482
ktimer = 4948512912590 (kdelta=4998), tick=31670482
ktimer = 4948512917606 (kdelta=5016), tick=31670482
ktimer = 4948512922597 (kdelta=4991), tick=31670482
ktimer = 4948512927605 (kdelta=5008), tick=31670482
ktimer = 4948512932591 (kdelta=4986), tick=31670482
ktimer = 4948512937591 (kdelta=5000), tick=31670482
ktimer = 4948512942592 (kdelta=5001), tick=31670482
ktimer = 4948512947589 (kdelta=4997), tick=31670482
ktimer = 4948512952589 (kdelta=5000), tick=31670482
ktimer = 4948512957616 (kdelta=5027), tick=31670482
ktimer = 4948512962590 (kdelta=4974), tick=31670482
ktimer = 4948512967589 (kdelta=4999), tick=31670482
ktimer = 4948512972589 (kdelta=5000), tick=31670483, tick_delta=159999
</code></pre></div></div>

<p>Unfortunately the windows kernel makes no effort to minimize timer jitter, it doesn’t try to compute a common factor of the requested periods, it simply uses the minimum period, if you need low jitter the only option is to set the kernel timer to the maximum available resolution. The downside of this is using 0.5ms intervals generates 2000 kernel interrupts per second, while that sounds bad it doesn’t really have any noticeable effect on performance, Microsoft should just use a fixed the interval and be done with it.</p>

<p>In the above code another useful value from <code class="language-plaintext highlighter-rouge">0x7FFE0008</code> in <code class="language-plaintext highlighter-rouge">kuser_shared</code> was used, this is the last kernel interrupt time in 100ns system units. Reading the last interrupt time is a much better way to measure elapsed time than GetTickCount(), its higher resolution and more accurate. One way to get the last kernel timer interrupt time is to directly read <code class="language-plaintext highlighter-rouge">0x7FFE0008</code>, the best way is to use <code class="language-plaintext highlighter-rouge">QueryInterruptTime()</code> which does exactly the same:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">QueryInterruptTime:</span>
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mh">7FFE0008h</span>  
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>  
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span><span class="nb">rax</span>  
  <span class="nf">ret</span>  
</code></pre></div></div>

<p>Windows 95 added the <code class="language-plaintext highlighter-rouge">timeGetTime</code> API as part of the multimedia APIs, the same APIs first showed up on NT based operating systems in Windows2000. These new APIs were still only accurate to integer milliseconds but apps could get 1ms resolution too. These APIs still weren’t great for accurately measuring elapsed time or scheduling video frames but given the lack of better options both games and multimedia apps used these extensively, even today these APIs are still used everywhere. Applications used <code class="language-plaintext highlighter-rouge">timeBeginPeriod</code> to set the resolution of the timer, as you can probably guess, this is just wrapper for <code class="language-plaintext highlighter-rouge">NtSetTimerResolution</code> with input quantized to whole milliseconds, with 1ms being the minimum. This is why 1ms shows up quite often in the above timer resolution log.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">timeGetTime:</span>
  <span class="nf">sub</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">28h</span>  
  <span class="nf">xor</span>         <span class="nb">r9d</span><span class="p">,</span><span class="nb">r9d</span>  
  <span class="nf">lea</span>         <span class="nb">rdx</span><span class="p">,[</span><span class="nv">TimeInit</span><span class="p">]</span>  
  <span class="nf">xor</span>         <span class="nb">r8d</span><span class="p">,</span><span class="nb">r8d</span>  
  <span class="nf">lea</span>         <span class="nb">rcx</span><span class="p">,[</span><span class="nv">g_TimeInitOnce</span><span class="p">]</span>  
  <span class="nf">call</span>        <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">__imp_InitOnceExecuteOnce</span><span class="p">]</span>   <span class="c1">;Only run the init code once, from any thread within a given process</span>
  <span class="nf">nop</span>         <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="o">+</span><span class="nb">rax</span><span class="p">]</span>  
  <span class="nf">mov</span>         <span class="nb">ecx</span><span class="p">,</span><span class="mh">7FFE0008h</span>                           <span class="c1">;last interrupt time</span>
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="mh">346DC5D63886594Bh</span>                   <span class="c1">;fixed point multiply by 1/100000</span>
  <span class="nf">mov</span>         <span class="nb">rcx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span>  
  <span class="nf">sub</span>         <span class="nb">rcx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">TimerData</span><span class="p">]</span>               <span class="c1">;subtract raw init time from TimerData  </span>
  <span class="nf">imul</span>        <span class="nb">rcx</span>  
  <span class="nf">sar</span>         <span class="nb">rdx</span><span class="p">,</span><span class="mh">0Bh</span>  
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">rdx</span>  
  <span class="nf">shr</span>         <span class="nb">rax</span><span class="p">,</span><span class="mh">3Fh</span>  
  <span class="nf">add</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">rdx</span>  
  <span class="nf">add</span>         <span class="nb">eax</span><span class="p">,</span><span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">TimerData</span><span class="o">+</span><span class="mh">8h</span><span class="p">]</span>            <span class="c1">;add on the init time in ms from TimerData+8 </span>
  <span class="nf">add</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">28h</span>  
  <span class="nf">ret</span>  
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">timeGetTime</code> just returns a scaled and offset version of the 64bit interrupt time. The multimedia timers are significantly better than <code class="language-plaintext highlighter-rouge">GetTickCount</code> but there is no point in using them in new code as there is far less cpu overhead by calling <code class="language-plaintext highlighter-rouge">QueryInterruptTime</code> and you get 100ns accuracy (you are still at the whim of the kernel timer interrupt interval if you don’t set it yourself).</p>

<p>Using <code class="language-plaintext highlighter-rouge">QueryInterruptTime</code> after setting the timer resolution to 0.5ms:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">old_tick</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">tick</span><span class="p">;</span>
    <span class="n">QueryInterruptTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tick</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tick</span> <span class="o">!=</span> <span class="n">old_tick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">double</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">tick</span> <span class="o">-</span> <span class="n">old_tick</span><span class="p">)</span> <span class="o">/</span> <span class="mf">10000.0</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"delta = %0.6f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
      <span class="n">old_tick</span> <span class="o">=</span> <span class="n">tick</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The result is quite stable, the interrupt time is within a few microseconds of the expected time, but half a millisecond is the smallest interval that can be measured and this still can’t accurately measure a 16.6ms frame time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>delta = 0.500100
delta = 0.502400
delta = 0.497900
delta = 0.499500
delta = 0.500200
delta = 0.500200
delta = 0.499800
delta = 0.500400
delta = 0.499600
delta = 0.500100
delta = 0.499900
delta = 0.499900
delta = 0.500500
</code></pre></div></div>

<p>Windows also provides an API called <code class="language-plaintext highlighter-rouge">GetSystemTimeAsFileTime</code> which returns the system current time as a file time. Within Windows, system time and file time are both in units of 100ns, system time is the elapsed time since boot while file time is the elapsed time since the epoch (Jan 1st 1601). However this API is also driven by the same timer interrupt timestamp but instead of reading <code class="language-plaintext highlighter-rouge">0x7FFE0008</code> which is the system timestamp, it reads <code class="language-plaintext highlighter-rouge">0x7FFE0014</code> which is the file time timestamp of the last timer interrupt.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">; This API splits the 64bit result in to a pair of 32bit values instead of directly returning a 64bit value. </span>
<span class="nl">GetSystemTimeAsFileTime:</span>
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mh">7FFE0014h</span>  
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>  
  <span class="nf">mov</span>         <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span><span class="nb">eax</span>  
  <span class="nf">shr</span>         <span class="nb">rax</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">mov</span>         <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span><span class="nb">eax</span>  
  <span class="nf">ret</span>  
</code></pre></div></div>

<p>There is a precise version of this API called <code class="language-plaintext highlighter-rouge">GetSystemTimePreciseAsFileTime</code> which is a wrapper for the native function <code class="language-plaintext highlighter-rouge">rtlGetSystemTimePrecise</code> and internally it uses native function <code class="language-plaintext highlighter-rouge">rtlQueryPerformanceCounter</code> along the last interrupt time and some other magic values within kuser_shared, ultimately it returns the file time of when the API was actually called.</p>

<blockquote>
  <p>This function uses address <code class="language-plaintext highlighter-rouge">0x7FFE0340</code> which is the incrementing tick count of the kernel timer interrupt. This counter is shifted left one bit so it appears to increment by 2, and the bottom bit is a lock bit. It’s very difficult to catch the lock bit set but I believe it is set while the kernel interrupt executes to indicate the timer values are changing. There are a lot of timer related values within <code class="language-plaintext highlighter-rouge">kuser_shared</code> and they can’t all be updated atomically, especially from a multi-processor point of view. You’ll see this value being used in the following code:</p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">RtlGetSystemTimePrecise:</span>
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">10h</span><span class="p">],</span><span class="nb">rbx</span>  
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">18h</span><span class="p">],</span><span class="nb">rbp</span>  
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">20h</span><span class="p">],</span><span class="nb">rsi</span>  
  <span class="nf">push</span>        <span class="nb">rdi</span>  
  <span class="nf">push</span>        <span class="nv">r12</span>  
  <span class="nf">push</span>        <span class="nv">r13</span>  
  <span class="nf">push</span>        <span class="nv">r14</span>  
  <span class="nf">push</span>        <span class="nv">r15</span>  
  <span class="nf">sub</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">mov</span>         <span class="nb">edi</span><span class="p">,</span><span class="mh">7FFE0358h</span>         
  <span class="nf">lea</span>         <span class="nb">r12d</span><span class="p">,[</span><span class="nb">rdi</span><span class="o">-</span><span class="mh">18h</span><span class="p">]</span>  
  <span class="nf">lea</span>         <span class="nb">r13d</span><span class="p">,[</span><span class="nb">rdi</span><span class="o">-</span><span class="mh">10h</span><span class="p">]</span>
<span class="nl">retry2:</span>  
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mh">7FFE0368h</span>  
  <span class="nf">mov</span>         <span class="nb">ecx</span><span class="p">,</span><span class="mh">7FFE0014h</span>
<span class="nl">retry1:</span>  
  <span class="nf">mov</span>         <span class="nb">rbx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r12</span><span class="p">]</span>                              <span class="c1">;0x340 - kernel timer counter + lock</span>
  <span class="nf">test</span>        <span class="nb">bl</span><span class="p">,</span><span class="mi">1</span>  
  <span class="nf">jne</span>         <span class="nv">pause1</span>                                           <span class="c1">;if the lock in the bottom bit of 0x340 is set, pause and try again (aka locked)</span>
  <span class="nf">mov</span>         <span class="nv">r14</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span>                              <span class="c1">;load system time for last interrupt  </span>
  <span class="nf">lea</span>         <span class="nb">rcx</span><span class="p">,[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">50h</span><span class="p">]</span>                                    <span class="c1">;result location of RtlQueryPerformanceCounter</span>
  <span class="nf">mov</span>         <span class="nb">rbp</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r13</span><span class="p">]</span>                              <span class="c1">;baseline qpc interrupt time</span>
  <span class="nf">mov</span>         <span class="nv">r15</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>                              <span class="c1">;qpc system time increment</span>
  <span class="nf">mov</span>         <span class="nb">si</span><span class="nv">l</span><span class="p">,</span><span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>                               <span class="c1">;time shift</span>
  <span class="nf">call</span>        <span class="nv">RtlQueryPerformanceCounter</span>                       <span class="c1">;get the qpc time stamp</span>
  <span class="nf">nop</span>  
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r12</span><span class="p">]</span>                              <span class="c1">;reload the interrupt counter/lock from 0x340</span>
  <span class="nf">cmp</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">rbx</span>  
  <span class="nf">jne</span>         <span class="nv">pause2</span>                                           <span class="c1">;if a timer interrupt has occurred or the lock has changed, spin and try again  </span>
  <span class="nf">mov</span>         <span class="nb">rdx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">50h</span><span class="p">]</span>                          <span class="c1">;result of RtlQueryPerformanceCounter</span>
  <span class="nf">mov</span>         <span class="nb">edi</span><span class="p">,</span><span class="mi">0</span>                                            <span class="c1">;delta time from last interrupt</span>
  <span class="nf">cmp</span>         <span class="nb">rdx</span><span class="p">,</span><span class="nb">rbp</span>                                          <span class="c1">;current qpc vs qpc interrupt time  </span>
  <span class="nf">jbe</span>         <span class="nv">comp_result</span>                                      <span class="c1">;qpc is below or equal (shouldn't happen), delta is zero, return the last interrupt</span>
  <span class="nf">sub</span>         <span class="nb">rdx</span><span class="p">,</span><span class="nb">rbp</span>                                          <span class="c1">;qpc delta since last interrupt		</span>
  <span class="nf">dec</span>         <span class="nb">rdx</span>	                                   
  <span class="nf">test</span>        <span class="nb">si</span><span class="nv">l</span><span class="p">,</span><span class="nb">si</span><span class="nv">l</span>  
  <span class="nf">je</span>          <span class="nv">skip_shift</span>                                       <span class="c1">;if shift is zero, skip shifting</span>
  <span class="nf">mov</span>         <span class="nb">cl</span><span class="p">,</span><span class="nb">si</span><span class="nv">l</span>  
  <span class="nf">shl</span>         <span class="nb">rdx</span><span class="p">,</span><span class="nb">cl</span>                                           <span class="c1">;shift qpc delta by the shift amount</span>
<span class="nl">skip_shift:</span>
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="nv">r15</span>                                          <span class="c1">;qpc system time increment  </span>
  <span class="nf">mul</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">rdx</span>                                          <span class="c1">;multiply the time delta by the time increment to compute 100ns  </span>
  <span class="nf">mov</span>         <span class="nb">rdi</span><span class="p">,</span><span class="nb">rdx</span>  
  <span class="nf">mov</span>         <span class="nb">rbx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">58h</span><span class="p">]</span>  
<span class="nl">comp_result:</span>
  <span class="nf">lea</span>         <span class="nb">rax</span><span class="p">,[</span><span class="nv">r14</span><span class="o">+</span><span class="nb">rdi</span><span class="p">]</span>                                    <span class="c1">;add 100ns unit delta time to the baseline interrupt time in 100ns</span>
  <span class="nf">mov</span>         <span class="nb">rbp</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">60h</span><span class="p">]</span>  
  <span class="nf">mov</span>         <span class="nb">rsi</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">68h</span><span class="p">]</span>  
  <span class="nf">add</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">pop</span>         <span class="nv">r15</span>  
  <span class="nf">pop</span>         <span class="nv">r14</span>  
  <span class="nf">pop</span>         <span class="nv">r13</span>  
  <span class="nf">pop</span>         <span class="nv">r12</span>  
  <span class="nf">pop</span>         <span class="nb">rdi</span>  
  <span class="nf">ret</span>  
  <span class="nf">int</span>         <span class="mi">3</span>  
<span class="nl">pause1:</span>
  <span class="nf">pause</span>  
  <span class="nf">jmp</span>         <span class="nv">retry1</span>   
<span class="nl">pause2:</span>
  <span class="nf">pause</span>  
  <span class="nf">jmp</span>         <span class="nv">retry2</span>
</code></pre></div></div>

<p>This is the first API that takes us away from times based on the kernel timer interrupt to a now time of when the API was actually called, its the first API to eliminate the kernel timer jitter and the first API that can be correlated to wall time. The implementation of <code class="language-plaintext highlighter-rouge">RtlGetSystemTimePrecise</code> jumps through some hoops because it always returns time in 100ns units and although it uses <code class="language-plaintext highlighter-rouge">rtlQueryPerformanceCounter</code> it has to do a scale and offset because <code class="language-plaintext highlighter-rouge">rtlQueryPerformanceCounter</code> doesn’t have a fixed frequency.</p>

<blockquote>
  <p>Following the typical NT native API pattern, the user api <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> and <code class="language-plaintext highlighter-rouge">rtlQueryPerformanceCounter</code> are the same thing.</p>
</blockquote>

<p>Windows NT system and file times have always been in 100ns units so it would make sense that <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> would return the same 100ns units but for some reason this took until windows 10 build 1607 (Anniversary update in 2016). Today, it is mostly true that the frequency of <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> has been fixed at 10Mhz but its not guaranteed, make assumptions at your own risk.  Over the years <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> has used a range of frequencies depending on the source timer but it will always have resolution greater than 1us.</p>

<p>The frequency of <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> can be obtained via <code class="language-plaintext highlighter-rouge">QueryPerformanceFrequency</code> and all this does is load and return the 64bit value at <code class="language-plaintext highlighter-rouge">0x7FEE0300</code> which is set by the kernel once at boot and never changes at runtime.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">QueryPerformanceFrequency:</span>
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="mh">7FFE0300h</span><span class="p">]</span>  
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">],</span><span class="nb">rax</span>  
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mi">1</span>  
  <span class="nf">ret</span> 
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> and <code class="language-plaintext highlighter-rouge">rtlQueryPerformanceCounter</code> have a native equivalent called <code class="language-plaintext highlighter-rouge">NtQueryPerformanceCounter</code>. The big difference is that <code class="language-plaintext highlighter-rouge">NtQueryPerformanceCounter</code> is <em>always</em> a syscall to the kernel, even though it computes the exact same result.</p>
</blockquote>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">QueryPerformanceCounter:</span>
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span><span class="nb">rbx</span>  
  <span class="nf">push</span>        <span class="nb">rdi</span>  
  <span class="nf">sub</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mh">7FFE03C6h</span>                     <span class="c1">;qpc flags address</span>
  <span class="nf">mov</span>         <span class="nb">rbx</span><span class="p">,</span><span class="nb">rcx</span>  
  <span class="nf">movzx</span>       <span class="nb">r9d</span><span class="p">,</span><span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>                <span class="c1">;load qpc flags</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mi">1</span>                             <span class="c1">;check bypass syscall  </span>
  <span class="nf">je</span>          <span class="nv">use_syscall</span>                       <span class="c1">;NtQueryPerformanceCounter (syscall 31h)</span>
  <span class="nf">mov</span>         <span class="nb">r11d</span><span class="p">,</span><span class="mh">7FFE03B8h</span>                    <span class="c1">;qpc bias address</span>
  <span class="nf">mov</span>         <span class="nv">r11</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r11</span><span class="p">]</span>               <span class="c1">;load qpc bias </span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mi">2</span>                             <span class="c1">;check qpc flags for using hypervisor page</span>
  <span class="nf">je</span>          <span class="nv">no_hyperv</span>                         <span class="c1">;no hypervisor page</span>

  <span class="nf">mov</span>         <span class="nv">r8</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="mh">7FFBB84332A8h</span><span class="p">]</span>      <span class="c1">;RtlpHypervisorSharedUserVa = 000000007FFE1000</span>
  <span class="nf">test</span>        <span class="nv">r8</span><span class="p">,</span><span class="nv">r8</span>                             <span class="c1">;is the hypervisor page null??</span>
  <span class="nf">je</span>          <span class="nv">use_syscall</span>                       <span class="c1">;if null, use syscall</span>
<span class="nl">loop_hyperv:</span>
  <span class="nf">mov</span>         <span class="nb">r10d</span><span class="p">,</span><span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span><span class="p">]</span>               <span class="c1">;load cookie from RtlpHypervisorSharedUserVa+0</span>
  <span class="nf">test</span>        <span class="nb">r10d</span><span class="p">,</span><span class="nb">r10d</span>                         <span class="c1">;is the cookie zero?</span>
  <span class="nf">je</span>          <span class="nv">use_syscall</span>                       <span class="c1">;if cookie is zero use syscall</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="nb">r9b</span>                           <span class="c1">;is rdtscp available? </span>
  <span class="nf">jns</span>         <span class="nv">use_rdtsc_hyperv</span>                  <span class="c1">;if no use rdtsc and some combo of lfence/mfence</span>
  <span class="nf">rdtscp</span>  
<span class="nl">rdtsc_result_hyperv:</span>
  <span class="nf">shl</span>         <span class="nb">rdx</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">or</span>          <span class="nb">rdx</span><span class="p">,</span><span class="nb">rax</span>                           <span class="c1">;make 64bit result from rdtsc  </span>
  <span class="nf">mov</span>         <span class="nb">rax</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>              <span class="c1">;load scale at RtlpHypervisorSharedUserVa+8  </span>
  <span class="nf">mov</span>         <span class="nb">rcx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span><span class="o">+</span><span class="mh">10h</span><span class="p">]</span>            <span class="c1">;load offset at RtlpHypervisorSharedUserVa+16</span>
  <span class="nf">mul</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">rdx</span>                           <span class="c1">;multiply by scale</span>
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nv">r8</span><span class="p">]</span>                <span class="c1">;reload cookie from RtlpHypervisorSharedUserVa+0</span>
  <span class="nf">add</span>         <span class="nb">rdx</span><span class="p">,</span><span class="nb">rcx</span>                           <span class="c1">;add the offset</span>
  <span class="nf">cmp</span>         <span class="nb">eax</span><span class="p">,</span><span class="nb">r10d</span>                
  <span class="nf">jne</span>         <span class="nv">loop_hyperv</span>                       <span class="c1">;do again if hypervisor cookie as changed, maybe the scale/offset changed.</span>

<span class="nl">compute_result:</span>
  <span class="nf">mov</span>         <span class="nb">cl</span><span class="p">,</span><span class="kt">byte</span> <span class="nv">ptr</span> <span class="p">[</span><span class="mh">7FFE03C7h</span><span class="p">]</span>           <span class="c1">;load qpc shift</span>
  <span class="nf">lea</span>         <span class="nb">rax</span><span class="p">,[</span><span class="nb">rdx</span><span class="o">+</span><span class="nv">r11</span><span class="p">]</span>                     <span class="c1">;add on qpc bias</span>
  <span class="nf">shr</span>         <span class="nb">rax</span><span class="p">,</span><span class="nb">cl</span>                            <span class="c1">;shift the result right</span>
  <span class="nf">mov</span>         <span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rbx</span><span class="p">],</span><span class="nb">rax</span>               <span class="c1">;store result  </span>
  <span class="nf">mov</span>         <span class="nb">eax</span><span class="p">,</span><span class="mi">1</span>                             <span class="c1">;return true</span>
  <span class="nf">mov</span>         <span class="nb">rbx</span><span class="p">,</span><span class="kt">qword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span><span class="o">+</span><span class="mh">30h</span><span class="p">]</span>  
  <span class="nf">add</span>         <span class="nb">rsp</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">pop</span>         <span class="nb">rdi</span>  
  <span class="nf">ret</span>  

<span class="c1">;main code path if the hypervisor isn't being used</span>
<span class="nl">no_hyperv:</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="nb">r9b</span>                       <span class="c1">;is rdtscp available</span>
  <span class="nf">jns</span>         <span class="nv">use_rdtsc</span>                     <span class="c1">;if not, use rdtsc</span>
  <span class="nf">rdtscp</span> 
<span class="nl">rdtsc_result:</span>                               <span class="c1">;if using rdtsc, it returns here</span>
  <span class="nf">shl</span>         <span class="nb">rdx</span><span class="p">,</span><span class="mh">20h</span>  
  <span class="nf">or</span>          <span class="nb">rdx</span><span class="p">,</span><span class="nb">rax</span>                       <span class="c1">;make 64bit value </span>
  <span class="nf">jmp</span>         <span class="nv">compute_result</span>                <span class="c1">;compute final result and return</span>

<span class="c1">;this is the hypervisor rdtsc path, identical to below, we just check sync flags prior to rdtsc</span>
<span class="nl">use_rdtsc_hyperv:</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mh">20h</span>                       <span class="c1">;use lfence?</span>
  <span class="nf">je</span>          <span class="nv">no_lfence_hyperv</span>  
  <span class="nf">lfence</span>  
  <span class="nf">jmp</span>         <span class="nv">read_tsc_hyperv</span>  
<span class="nl">no_lfence_hyperv:</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mh">10h</span>                       <span class="c1">;use mfence?</span>
  <span class="nf">je</span>          <span class="nv">read_tsc_hyperv</span>  
  <span class="nf">mfence</span>  
<span class="nl">read_tsc_hyperv:</span>
  <span class="nf">rdtsc</span>  
  <span class="nf">jmp</span>         <span class="nv">rdtsc_result_hyperv</span> 

<span class="c1">;this is none hypervisor rdtsc, we might need a sync instruction before the rdtsc</span>
<span class="nl">use_rdtsc:</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mh">20h</span>                       <span class="c1">;use lfence for sync</span>
  <span class="nf">je</span>          <span class="nv">skip_lfence</span>  
  <span class="nf">lfence</span>  
  <span class="nf">jmp</span>         <span class="nv">read_tsc</span>
<span class="nl">skip_lfence:</span>
  <span class="nf">test</span>        <span class="nb">r9b</span><span class="p">,</span><span class="mh">10h</span>                       <span class="c1">;use mfence for sync</span>
  <span class="nf">je</span>          <span class="nv">read_tsc</span>  
  <span class="nf">mfence</span>
<span class="nl">read_tsc:</span>  
  <span class="nf">rdtsc</span>  
  <span class="nf">jmp</span>         <span class="nv">rdtsc_result</span>  
<span class="nl">use_syscall:</span>
  <span class="nf">....</span>                
</code></pre></div></div>

<p>Dissecting the above code there are a few different paths but ultimately only 2 modes of operation. It’s either a syscall or some derivative of the TSC read with either <code class="language-plaintext highlighter-rouge">RDTSC</code> or <code class="language-plaintext highlighter-rouge">RDTSCP</code>. The difference between these two almost identical instructions is the original <code class="language-plaintext highlighter-rouge">RDTSC</code> is a speculative instruction, it doesn’t necessarily wait until all previous instructions to execute before reading the counter. Similarly, subsequent instructions may begin executing before the timer is read. This can cause problems if the programmer expects the timestamp to be take at the exact location of the instruction. Making this instruction behave requires some form of synchronization instruction:</p>

<ul>
  <li>If software requires <code class="language-plaintext highlighter-rouge">RDTSC</code> to be executed only after all previous instructions have executed on Intel platforms, it can execute <code class="language-plaintext highlighter-rouge">LFENCE</code> immediately before <code class="language-plaintext highlighter-rouge">RDTSC</code>.</li>
  <li>If software requires <code class="language-plaintext highlighter-rouge">RDTSC</code> to be executed only after all previous instructions have executed on AMD platforms, it can execute <code class="language-plaintext highlighter-rouge">MFENCE</code> immediately before <code class="language-plaintext highlighter-rouge">RDTSC</code>. Technically this is slower than the Intel solution as it waits until all previous loads and stores are globally visible. Executing <code class="language-plaintext highlighter-rouge">LFENCE</code> on AMD hardware doesn’t synchronize as intended.</li>
  <li>If software requires <code class="language-plaintext highlighter-rouge">RDTSC</code> to be executed prior to execution of any subsequent instruction, it can execute <code class="language-plaintext highlighter-rouge">LFENCE</code> immediately after <code class="language-plaintext highlighter-rouge">RDTSC</code>.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">RDTSCP</code> [Available when <code class="language-plaintext highlighter-rouge">CPUID.80000001h:EDX[27]</code>, is set] is a none speculative version of <code class="language-plaintext highlighter-rouge">RDTSC</code>, equivalent to the first two items above. It waits for all prior instructions to execute before reading the timer and it works the same on AMD and Intel hardware. It doesn’t prevent future instructions from starting to execute, which software can prevent by executing <code class="language-plaintext highlighter-rouge">LFENCE</code> after <code class="language-plaintext highlighter-rouge">RDTSCP</code> (item 3 above). A feature of this newer instruction, unrelated to timers, is the model specific register IA32_TSC_AUX is returned in register ECX, the windows scheduler puts the processor ID in this register, which software can use to determine if your thread is hopping processors (linux does something similar but its entirely dependent on the operating system to set this model specific register).</p>

<p>Going back to QueryPerformanceCounter, you can see all of the above options being used, the code flow is controlled by the QPC flags at <code class="language-plaintext highlighter-rouge">0x7FFE03C6h</code>, the DDK names the various flags as follows:</p>

<p><code class="language-plaintext highlighter-rouge">SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED = 0x01</code> Set if QPC should bypass the syscall and use the timestamp instructions, this will only be set if the timestamp is invariant. This flag first appeared in Window8.1. If this bit is clear QPC just calls <code class="language-plaintext highlighter-rouge">NtQueryPerformanceCounter</code> which is always a syscall, this allows motherboard timers to be used which are only accessible from kernel mode. If the bypass is not enabled then <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> is always a system call with significant cpu overhead, making it somewhat unsuitable for high frequency operations as a single call can take a few microseconds to execute (many thousands of clock cycles).</p>

<p><code class="language-plaintext highlighter-rouge">SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE = 0x02</code> If set QPC uses the hypervisor page, this new memory page showed in Windows 10 v1607 and is mapped to all processes much the same way as <code class="language-plaintext highlighter-rouge">kuser_shared</code>. The memory page is used to apply a scale and offset to normalize the frequency to 10MHz (100ns units). This normalization can only occur if the hypervisor page is present so earlier versions of windows will not return a fixed 10Mhz.</p>

<p><code class="language-plaintext highlighter-rouge">SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE = 0x10</code> Use <code class="language-plaintext highlighter-rouge">MFENCE</code> for synchronization, not checked if <code class="language-plaintext highlighter-rouge">RDTSCP</code> is used, only used on AMD processors</p>

<p><code class="language-plaintext highlighter-rouge">SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE = 0x20</code> Use <code class="language-plaintext highlighter-rouge">LFENCE</code> for synchronization, not checked if <code class="language-plaintext highlighter-rouge">RDTDCP</code> is used, only used on Intel processors</p>

<p><code class="language-plaintext highlighter-rouge">SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP = 0x80</code> If this is set <code class="language-plaintext highlighter-rouge">RDTSCP</code> is available and will be used in place of <code class="language-plaintext highlighter-rouge">RDTSC</code> and syncrhonization.</p>

<p>The syscall is avoided if at all possible and the code path is optimized for using RDTSCP with the hypervisor page to normalize to 10Mhz, this is the code path that has no branches and is the expected code path on typical windows 10 or later machine. Thre are a few other options that can be returned:</p>

<ul>
  <li>
    <p>User mode TSC via <code class="language-plaintext highlighter-rouge">RDTSC or RDTSCP</code> with hypervisor normalization to 10Mhz. CPU cost is 100ish cycles.</p>
  </li>
  <li>
    <p>User mode TSC via <code class="language-plaintext highlighter-rouge">RDTSC or RDTSCP</code> with a shift. On the test machine the shift is set to 10 giving a frequency of 3.613000Mhz (approx 3.7GHz / 1024). CPU cost is about 100 cycles</p>
  </li>
  <li>
    <p>System call.  If this path is being used it will most likely be using the HPET with a frequency of 14.318180MHz, it could also use a PMTimer at 3.579545MHz (exactly 4x slower than the HPET) but its unlikely. CPU cost for the syscall path is thousands of cycles.</p>
  </li>
</ul>

<blockquote>
  <p>Windows 10/11 can be forced to use the HPET counter. From an administrator terminal using <code class="language-plaintext highlighter-rouge">bcdedit /set useplatformclock true</code>. While this could be useful for testin I recommend you don’t leave this boot variable set because it can have some nasty side effects, use <code class="language-plaintext highlighter-rouge">bcdedit /deletevalue useplatformclock</code> to delete the variable and go back to the default. You need to reboot after changing this setting. 
I highly recommend you test with this especially if you are making some high performance media app or game. There are machines out there that use this path and it has caused numerous problems for a handful of commercial games. It also changes the QPC frequency so its no longer the normalized 10Mhz.</p>
</blockquote>

<p>What is this hypervisor page?? Unfortunately, there isn’t much information on it. It first appeared in anniversary update of windows 10 (version 1607) it seems to only be used by <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code>. It’s address isn’t fixed but on all the machines tested it always shows up very close to <code class="language-plaintext highlighter-rouge">kuser_shared</code>, on this test machine it is directly after the kernel page at <code class="language-plaintext highlighter-rouge">0x7ffe1000</code>. You can query the local process address by using native API <code class="language-plaintext highlighter-rouge">NtQuerySystemInformation</code> with query class ID <code class="language-plaintext highlighter-rouge">0xc5</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">extern</span> <span class="s">"C"</span> <span class="n">NTSYSAPI</span> <span class="n">NTSTATUS</span> <span class="n">NTAPI</span>  <span class="nf">NtQuerySystemInformation</span><span class="p">(</span>
    <span class="n">ULONG</span>   <span class="n">SystemInformationClass</span><span class="p">,</span>
    <span class="n">PVOID</span>   <span class="n">SystemInformation</span><span class="p">,</span>
    <span class="n">ULONG</span>   <span class="n">SystemInformationLength</span><span class="p">,</span>
    <span class="n">PULONG</span>  <span class="n">ReturnLength</span>
  <span class="p">);</span>

  <span class="kt">void</span><span class="o">*</span> <span class="nf">GetHypervisorPageAddress</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">system_info</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">res_size</span><span class="p">;</span>
    <span class="n">NTSTATUS</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="mh">0xC5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">system_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">system_info</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">res_size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">system_info</span><span class="p">)))</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">system_info</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Now we can write some code to dump out the known data in the hypervisor page, and compute the TSC frequency as seen by the operating system.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">//known elements of the hypervisor page</span>
  <span class="k">struct</span> <span class="nc">HypervisorPage</span>
  <span class="p">{</span>
    <span class="kt">uint32_t</span>  <span class="n">cookie</span><span class="p">;</span>
    <span class="kt">uint32_t</span>  <span class="n">unused</span><span class="p">;</span> <span class="c1">//maybe cookie is 64bits but it's currently loaded as 32bits</span>
    <span class="kt">uint64_t</span>  <span class="n">rdtsc_scale</span><span class="p">;</span>
    <span class="kt">uint64_t</span>  <span class="n">rdtsc_offset</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//use the above function</span>
  <span class="n">HypervisorPage</span><span class="o">*</span> <span class="n">hv</span> <span class="o">=</span> <span class="p">(</span><span class="n">HypervisorPage</span><span class="o">*</span><span class="p">)</span><span class="n">GetHypervisorPageAddress</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hv</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"cookie: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hv</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"rdtsc_cale: %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hv</span><span class="o">-&gt;</span><span class="n">rdtsc_scale</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"rdtsc_offset: %llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hv</span><span class="o">-&gt;</span><span class="n">rdtsc_offset</span><span class="p">);</span>

    <span class="c1">//compute the tsc speed as an integer with 32bits of fraction</span>
    <span class="kt">int64_t</span> <span class="n">rem</span><span class="p">;</span>
    <span class="kt">int64_t</span> <span class="n">tsc_int</span> <span class="o">=</span> <span class="n">_div128</span><span class="p">((</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hv</span><span class="o">-&gt;</span><span class="n">rdtsc_scale</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rem</span><span class="p">);</span> 

    <span class="c1">//convert to a double</span>
    <span class="kt">double</span> <span class="n">tsc</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">tsc_int</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"tsc clock speed = %.6f"</span><span class="p">,</span> <span class="n">tsc</span><span class="o">*</span><span class="mf">10.0</span><span class="p">);</span> <span class="c1">//*10 for Mhz</span>

    <span class="c1">//this is hacky but surprisingly accurate (only because rdtsc_scale fits in 53bits)</span>
    <span class="c1">//double f = (double)0xffffffffffffffffULL / (double)hv-&gt;rdtsc_scale;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see from the disassembly of <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> that if the hypervisor cookie is zero the syscall is used, on Windows 11 the cookie starts at 0x1 and I assume increments if the hypervisor makes changes to the scale or offset, I’ve never seen this happen but it makes sense the hypervisor could change these values and QueryPerformanceCounter is written to handle it (In windows 10 the cookie used to be a value of ‘hAlt’). On my test machine rdtsc_scale is slighly different on every reboot so its probably being computed at startup, for example on the first boot <code class="language-plaintext highlighter-rouge">0x00b11b8333a4a9e5</code> which in 64bit fixed point is 1/370.035209, on the 2nd boot <code class="language-plaintext highlighter-rouge">0x00b11b77df38e17c</code> or 1/370.0355705, both are very close to the divosr required to get 100ns units from a processor with a base speed of 3.7GHz.</p>

<p>Another time related use for <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntquerysysteminformation"><code class="language-plaintext highlighter-rouge">NtQuerySystemInformation</code></a> is to determine if <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> is going to use a syscall or if its going to stay in user mode. You could figure this out yourself the offical method (albiet somewhat undocumented) will be correct in the future. Knowing a syscall is going to be used might change how you use <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">DoesQPCBypassKernel</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION</span>
  <span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>

    <span class="c1">//0x00000001 = kernelqpc</span>
    <span class="n">ULONG</span> <span class="n">Flags</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">ValidFlags</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION</span> <span class="n">qpc_info</span><span class="p">;</span>
  <span class="n">ULONG</span> <span class="n">res_size</span><span class="p">;</span>

  <span class="n">qpc_info</span><span class="p">.</span><span class="n">Version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//must set the version on input (only version=1 is defined)</span>
  <span class="n">NTSTATUS</span> <span class="n">result</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="mh">0x7c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qpc_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qpc_info</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">res_size</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">res_size</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">qpc_info</span><span class="p">)))</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">qpc_info</span><span class="p">.</span><span class="n">ValidFlags</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>  <span class="c1">//is kernel flag valid</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">qpc_info</span><span class="p">.</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//if valid it needs to be zero to bypass</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//this is not actually false, but unknown</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Have we come full circle? Why don’t we use <code class="language-plaintext highlighter-rouge">RDTSC</code> for time stamps? If <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> is just a wrapper for <code class="language-plaintext highlighter-rouge">RDTSC/RDTSCP</code> then why not avoid all the overhead and execute the instructions directly? Is Microsoft correct in saying everybody should use QueryPerformanceCounter??? Well, it depends..</p>

<p>If <code class="language-plaintext highlighter-rouge">CPUID.80000007H:EDX[8]</code> indicates invariant timestamp support then there is little harm in making your own ultra low overhead timers using <code class="language-plaintext highlighter-rouge">RDTSC/RDTSCP</code>. <code class="language-plaintext highlighter-rouge">RDTSC</code> is the most optimal and I’ve never seen the lack of synchronization cause problems outside of profiling short code sequences. If you do things yourself you do have to figure out the base clock frequency, something that is given to you if you use <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code>. While I don’t see the timestamp instructions becoming unsable again, there is always a risk of some processor changing the invariant timer in ways software doesn’t expect, nobody expected <code class="language-plaintext highlighter-rouge">RDTSC</code> to cause as much trouble as it did when it was first used 30 years ago.</p>

<p>On a modern machine I don’t see any problem in using <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code>, especially if its bypassing the syscall, its plenty fast enough for anything other than maybe micro-profiling short sequences. <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> is pretty future proof when used properly and the OS handles the edge cases and platform differences. For general time keeping, no matter what the <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code> timer source may be, or even if its using a syscall, its insignificant overhead. I am starting to see numerous posts online where the frequency is assumed to be a fixed 10MHz, don’t do this! Today, I would only use <code class="language-plaintext highlighter-rouge">RDTSC</code> for careful micro profiling, or if thousands and thousands of timestamps are needed where just the overhead of the API calls is too much.</p>

<p>If you make your own timers and need the TSC frequency I recommend not using the above code outside of a development environment - it will cause you problems in the future and your app will be the one crashing in 10 years. It would be nice if Windows just had an API to give the TSC frequency but it doesn’t. On Intel processors <code class="language-plaintext highlighter-rouge">CPUID 16h</code> can be used to get the base speed but if you want to compute the TSC frequency you can do a one-time calibration by comparing TSC readings against a known system clock or even QueryPerformanceCounter itself, during development you can check your calibration code against the hypervisor frequency to see if if its reliable. If you use a good reference timer and throw out any outliers this type of calibration can be very accurate, it’s future proof, works on Intel and AMD and it accounts for things like virtualization and overclocking. Never calibrate against <code class="language-plaintext highlighter-rouge">GetTickCount</code>, it’ll never be accurate with the amount of jitter we saw earlier.</p>

<p>Finally, the invariant TSC might appear to have the same counter frequency as the base processor speed but it certainly doesn’t increment at that speed. Typically the invariant TSC runs on a much slower, stable and always running reference clock, say 25MHz, or 50Mhz or 100MHz. The core counter increments at this reference speed adding whatever multiplier is required to match the base speed. On my test machine the amount added is 148 to give the impression of a 3.7GHz counter, from this we can calculate a reference clock of 25MHz. On Intel processors this incremnent rate is available from <code class="language-plaintext highlighter-rouge">CPUID 15h</code>. However, things are not that simple because <code class="language-plaintext highlighter-rouge">RDTSC</code> always returns a value that is monotonically incrementing so won’t return the same value twice if you call it back to back. How this is implemented with respect to the reference clock and what is actually returned is model specific - for example some Intel processors only return even numbers. While its safe to assume the invariant TSC is accurate with wall time over long periods, you probably don’t want to use it to time ultra small sections of code, unless you know exactly how RDTSC is implemented on your particular processor.</p>

    </div>

    
    <div class="post__comments">
      <script async src="https://talk.hyvor.com/embed/embed.js" type="module"></script>
      <hyvor-talk-comments website-id=7818 page-id="/2024/02/25/timestamps"></hyvor-talk-comments>
    </div>
    

</article>


    <footer class="footer">
        <section class="footer__about">
          
          <p class="footer__about__copyright">© Tricky Bits 2024</p>
                            
        </section>            
</footer>

<div class="feed__description">
  If you like this content, follow us and subscribe on social media
<ul class="social-media-list"><a href="https://github.com/trickybitsblog"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#github"></use></svg></a><a href="https://instagram.com/trickybitsblog"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#instagram"></use></svg></a><a href="https://threads.net/trickybitsblog"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#threads"></use></svg></a><a href="https://www.twitter.com/trickybitsblog"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#twitter"></use></svg></a><a href="https://youtube.com/%40trickybits"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#youtube"></use></svg></a><a href="https://www.buzzsprout.com/2293587"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#buzzsprout"></use></svg></a><a href="https://discord.gg/3UaMJxKxPR"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#discord"></use></svg></a><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/img/social-icons.svg#rss"></use></svg></a></ul>
</div>
  


</body>
</html>